JavaScript supports two basic data structures for storing information, Arrays and Hashes.  Let's look at how we might add an Array and a Hash to a View Model.

```` TypeScript
class ViewModel {
    list = [];
    map = {};
}
````

However, just like regular properties, changes to these properties will be ignored.  Again, if we add our decorators, we can subscribe to changes.

```` TypeScript
class ViewModel {
    @array list = [];
    @hash map = {};
}
````

It's important to note that once an Array or Hashe is marked as observable, Cascade will automatically set its value to be an Array or Hash, even if we haven't initialized it.  We don't even have to write an initialization in the code.  Plus, we don't have to check if the property is truthy before doing lookups on it.  All of that is handled by Cascade!

So, we can simply write:

```` TypeScript
class ViewModel {
    @array list;
    @hash map;
}
````

We can also be more specific about what is stored in Arrays and Hashes.

```` TypeScript
class ViewModel {
    @array list: string[];
    @hash map: IHash<string>;
}
````

For this example, we may import `IHash` from Cascade, but TypeScript supports many other typing options.

## Reflection Polyfill

By default, Arrays must be decorated with `@array` and Hashes with `@hash`.  However, just like we can use `@observable` to decorate `Computed` properties, we can also use it to decorate Arrays, but only with some extra libraries.

In order to get this automatic type detection, we have to set up an experimental TypeScript Metadata feature.  First off, you must set `"emitDecoratorMetadata": true` in your `tsconfig.json` file.  Then, you must install the package `reflect-metadata` from npm.

Furthermore, for IE10 and below, you must also include `es6-shim` or similar polyfills.

Then, in your main TypeScript file, you must include:

```` TypeScript
import 'es6-shim';
import 'reflect-metadata';
````

> **Note:** This does not currently support Hashes.

## Legacy Browser Support

In general, Cascade fully supports older browsers, including Internet Explorer 9+.  However, Arrays and Hashes are one area where some special consideration must be made.

First off, Observable Hashes are not supported.  Their functionality can be emulated easily with ObservableArrays and a regular Hash object.

Secondly, Observable Arrays work slightly differently in Internet Explorer.  In modern browsers, we can simply write to any index and it will be detected.

```` TypeScript
viewModel.list[0] = 'value';
````

However, in Internet Explorer, we must use an explicit setter method.

```` TypeScript
ObserableArray.set(index: number, value: T): void;
````

Which in practice would look like:

```` TypeScript
viewModel.list.set(0, 'value');
````

However, TypeScript will complain that the `set` method doesn't exist on `Array`.  So, we can update our View Model to use `IArray<T>` instead of `T[]` or `Array<T>`.  This interface can be imported from Cascade.

```` TypeScript
class ViewModel {
    @array list: IArray<string>;
    @hash map: IHash<string>;
}
````


