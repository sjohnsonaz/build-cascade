{
    "docs": [
        {
            "location": "/",
            "text": "Cascade\n\n\nA modern library for creating user interfaces\n\n\nWritten for JavaScript and TypeScript, Cascade is a complete framework for displaying and synchronizing application data.\n\n\nUsing modern techniques, the framework simply \n\"gets out of your way\"\n.  You simply set up your \nApplication State\n, display it in a \nComponent\n, and Cascade handles the rest.  If you update the data, the DOM is automatically updated as well!\n\n\nPlus, using careful dependency tracking, updates are planned for maximum efficiency!\n\n\nGetting a Cascade application going is super easy!\n\n\n/* Import Cascade */\nimport Cascade, { Component, observable } from 'cascade';\n\n/* Define your Application State */\nclass ApplicationState {\n    @observable value = 'Some value';\n}\n\n/* Define your Component Props */\ninterface IViewProps {\n    applicationState: ApplicationState;\n}\n\n/* Define your Component */\nclass View extends Component<IViewProps> {\n    render() {\n        let { applicationState } = this.props;\n        return (\n            <div>{applicationState.value}</div>\n        );\n    }\n}\n\n/* Render your Application */\nlet applicationState = new ApplicationState();\nCascade.render(document.body, <View applicationState={applicationState} />);\n\n/* Update your Application State */\napplicationState.value = 'Some NEW value';\n\n\n\n\nSo go ahead and \nget started\n!",
            "title": "Home"
        },
        {
            "location": "/#cascade",
            "text": "",
            "title": "Cascade"
        },
        {
            "location": "/#a-modern-library-for-creating-user-interfaces",
            "text": "Written for JavaScript and TypeScript, Cascade is a complete framework for displaying and synchronizing application data.  Using modern techniques, the framework simply  \"gets out of your way\" .  You simply set up your  Application State , display it in a  Component , and Cascade handles the rest.  If you update the data, the DOM is automatically updated as well!  Plus, using careful dependency tracking, updates are planned for maximum efficiency!  Getting a Cascade application going is super easy!  /* Import Cascade */\nimport Cascade, { Component, observable } from 'cascade';\n\n/* Define your Application State */\nclass ApplicationState {\n    @observable value = 'Some value';\n}\n\n/* Define your Component Props */\ninterface IViewProps {\n    applicationState: ApplicationState;\n}\n\n/* Define your Component */\nclass View extends Component<IViewProps> {\n    render() {\n        let { applicationState } = this.props;\n        return (\n            <div>{applicationState.value}</div>\n        );\n    }\n}\n\n/* Render your Application */\nlet applicationState = new ApplicationState();\nCascade.render(document.body, <View applicationState={applicationState} />);\n\n/* Update your Application State */\napplicationState.value = 'Some NEW value';  So go ahead and  get started !",
            "title": "A modern library for creating user interfaces"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/",
            "text": "Using Cascade requires only a few steps.  It's designed for TypeScript, but is completely compatible with pure JavaScript.\n\n\nInstalling TypeScript\n\n\nFor simplicity in these tutorials, you can download a simple boilerplate at \nhttps://github.com/sjohnsonaz/ts-boilerplate\n.  Follow its instructions to get a TypeScript environment up and running.  Otherwise, you will need to set up Node, TypeScript, and Webpack to compile and run these projects.\n\n\nInstalling Cascade\n\n\nFor TypeScript, it is recommended to install Cascade via npm.  It should be installed as a \"dependency\" for most projects, unless you're creating a shared library.  Shared libraries should install Cascade as a \"peerDependency\".\n\n\nnpm install cascade --save\n\n\n\nCascade can also be downloaded from \nhttps://github.com/sjohnsonaz/cascade/releases\n.",
            "title": "Getting Started"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/#installing-typescript",
            "text": "For simplicity in these tutorials, you can download a simple boilerplate at  https://github.com/sjohnsonaz/ts-boilerplate .  Follow its instructions to get a TypeScript environment up and running.  Otherwise, you will need to set up Node, TypeScript, and Webpack to compile and run these projects.",
            "title": "Installing TypeScript"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/#installing-cascade",
            "text": "For TypeScript, it is recommended to install Cascade via npm.  It should be installed as a \"dependency\" for most projects, unless you're creating a shared library.  Shared libraries should install Cascade as a \"peerDependency\".  npm install cascade --save  Cascade can also be downloaded from  https://github.com/sjohnsonaz/cascade/releases .",
            "title": "Installing Cascade"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/",
            "text": "In this tutorial, we take a look at Cascade, what it can do, and the fundamental parts of any Cascade project.  You should already have a TypeScript environment running, and have included Cascade in your project dependencies.\n\n\nProject Organization\n\n\nAny Cascade project includes \nApplication State\n and \nComponents\n.  This is similar to many common patterns such as \nMVC\n or \nMVVM\n, where you have a distinct separation between your data, and how you display it.  Ultimately, the specifics of your pattern are up to you, but the overal concept is the same.  We will introduce some common patterns in later tutorials.\n\n\nBefore we get started, your TypeScript project should have a \ntsconfig.json\n file.  Open this file, and ensure the following options are set:\n\n\n\"jsx\": \"react\",\n\"reactNamespace\": \"Cascade\",\n\"experimentalDecorators\": true,\n\"emitDecoratorMetadata\": true\n\n\n\n\nThe \nemitDecoratorMetadata\n value is optional, as we will see later.\n\n\nAlso, ensure that you have \nsrc\n and \npublic\n directories in your project.\n\n\nBuilding your Project\n\n\nIt will be easier to develop our project if we can run it.  Let's start by setting up a simple set of files and getting the to build.\n\n\nInside the \npublic\n directory, create a file \nindex.html\n.  This will be the main HTML file that runs the project.\n\n\n<!DOCTYPE>\n<html>\n\n<head>\n    <title>Tutorial 0</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n    <script src=\"bundle/main.js\" type=\"text/javascript\"></script>\n</body>\n\n</html>\n\n\n\n\nThis file creates a \n<div>\n to mount our component, and then loads the script.  Note that we're loading our script from \nbundle/main.js\n, which is a file that doesn't currently exist.  We are going to build it later.\n\n\nInside the \nsrc/scripts\n directory, create a file \nmain.tsx\n.\n\n\nwindow.onload = function () {\n    console.log('started');\n}\n\n\n\n\nWe now must set up Webpack to build our \nmain.tsx\n file.  Inside the webpack configs (there are two if you're using the ts-boilerplate), ensure that the \nentry\n and \noutput\n objects have the correct values.  it should read:\n\n\n    entry: {\n        'main': './src/scripts/main.tsx'\n    },\n    output: {\n        filename: './public/bundle/[name].js',\n        libraryTarget: 'var',\n        library: '[name]'\n    },\n\n\n\n\nThis is likely very similar to what is already there.  Simply change \nmain.ts\n to \nmain.tsx\n, the filename from \ndist\n to \npublic\n, and remove the \n.min\n portion of the filename.\n\n\nNow to test it, run\n\n\nnpm run dev\n\n\n\nIf you want to run automatically as you're developing, call\n\n\nnpm run watch\n\n\n\nIf you want to run a minified version of the file, call\n\n\nnpm run min\n\n\n\nIf it is successful, open the \npublic/index.html\n file in your browser.  Open the browser's console, and you should see \nstarted\n printed to the screen.\n\n\nApplication State\n\n\nCascade stores its data in \nApplication State\n objects.  Depending on what you want to store, they may contain values, other objects, arrays, or even methods to manipulate the data.  \n\n\nLet's say we want to create a \nModel\n of a \nUser\n.  It should store common information for our users, like first and last name.  We also will want to edit it.\n\n\nSo, we start by declaring a class, and adding several properties.  Inside your project, create a folder \nsrc/scripts/models\n, and inside it a file \nUser.ts\n.\n\n\nexport default class User {\n    firstName: string;\n    lastName: string;\n}\n\n\n\n\nFantastic!  We now have a User class which will correctly store our data!  We have also exported it as default from this file.\n\n\nComponents\n\n\nCascade displays its data in \nComponents\n, which are simply classes that render to the DOM.  They may render Nodes, strings, numbers, nothing, or even other Components.\n\n\nSo, since we have our User model, let's display it!  Inside your project, create a folder \nsrc/scripts/views/user\n, and inside it a file \nUserView.tsx\n.\n\n\nFirst, we must import Cascade into the file.\n\n\nimport Cascade, { Component } from 'cascade';\n\n\n\n\nWe have imported Cascade, and the Component class.  While we will not necessarily use the \nCascade\n import directly in our code, the JSX interpreter will transpile our JSX statements into Cascade calls.  This process turns what appear to be XML elements into:\n\n\nCascade.createElement<T extends Object>(type: string | (new (props: T, ...children: Array<any>) => Component<T>), props: T, ...children: Array<any>): IVirtualNode<T>;`.\n\n\n\n\nNow we must import our User model.\n\n\nimport User from '../../models/User';\n\n\n\n\nWe now must define what properties our component takes.  Our component will take in a user.  These appear as XML Attributes in our JSX code.\n\n\nexport interface IUserViewProps {\n    user: User;\n}\n\n\n\n\nNext we need to define our component itself.\n\n\nexport default class UserView extends Component<IUserViewProps> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n            </div>\n        );\n    }\n}\n\n\n\n\nThis component takes in a user, and displays the \nfirstName\n and \nlastName\n inside to \n<p>\n elements, wrapped inside one \n<div>\n element.\n\n\nThere are a couple things to note:\n\n\n\n\nWe used the Props interface inside the Component definition.  This provides intellisense both when writing the component, and later when we use it.\n\n\nWe used object destructuring to get \nuser\n from \nthis.props\n.  This is a shorthand that is much simpler than \nlet user = this.props.user;\n.  It especially comes in handy if you're doing that for multiple properties.\n\n\nEvery component must define a render method, even if it returns nothing.\n\n\nA component may return exactly one value.  Here we wrapped our multiple \n<p>\n tags in a single \n<div>\n tag.\n\n\nWe user the \n{}\n notation to insert the \nuser\n values into the elements.\n\n\n\n\nRendering\n\n\nWe now must render our \nApplication State\n into \nComponent\n and display it to the DOM.\n\n\nInside the \nmain.tsx\n we must import all of our files, and then render them.\n\n\nimport Cascade from 'cascade'\n\nimport User from './models/User';\nimport UserView from './views/UserView';\n\nwindow.onload = function () {\n    var user = new User();\n    user.firstName = 'First';\n    user.lastName = 'Last';\n\n    Cascade.render(\n        document.getElementById('root'),\n        <UserView user={User} />\n    );\n};\n\n\n\n\nThere are a couple things to note:\n\n\n\n\nWe imported Cascade, our \nUser\n, and our \nUserView\n.\n\n\nWe write our code inside the onload function to ensure it runs after everything is ready.\n\n\nWe create a new user and set the first and last name properties.\n\n\nWe get the \nroot\n element from the DOM\n\n\nWe create a new \nUserView\n with JSX, pass in the user.\n\n\nWe pass the \nroot\n element and the \nUserView\n to \nCascade.render()\n.\n\n\n\n\nNow build the project and run the HTML file in your browser.  It should display your user in the HTML you specified.",
            "title": "Displaying Data"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#project-organization",
            "text": "Any Cascade project includes  Application State  and  Components .  This is similar to many common patterns such as  MVC  or  MVVM , where you have a distinct separation between your data, and how you display it.  Ultimately, the specifics of your pattern are up to you, but the overal concept is the same.  We will introduce some common patterns in later tutorials.  Before we get started, your TypeScript project should have a  tsconfig.json  file.  Open this file, and ensure the following options are set:  \"jsx\": \"react\",\n\"reactNamespace\": \"Cascade\",\n\"experimentalDecorators\": true,\n\"emitDecoratorMetadata\": true  The  emitDecoratorMetadata  value is optional, as we will see later.  Also, ensure that you have  src  and  public  directories in your project.",
            "title": "Project Organization"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#building-your-project",
            "text": "It will be easier to develop our project if we can run it.  Let's start by setting up a simple set of files and getting the to build.  Inside the  public  directory, create a file  index.html .  This will be the main HTML file that runs the project.  <!DOCTYPE>\n<html>\n\n<head>\n    <title>Tutorial 0</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n    <script src=\"bundle/main.js\" type=\"text/javascript\"></script>\n</body>\n\n</html>  This file creates a  <div>  to mount our component, and then loads the script.  Note that we're loading our script from  bundle/main.js , which is a file that doesn't currently exist.  We are going to build it later.  Inside the  src/scripts  directory, create a file  main.tsx .  window.onload = function () {\n    console.log('started');\n}  We now must set up Webpack to build our  main.tsx  file.  Inside the webpack configs (there are two if you're using the ts-boilerplate), ensure that the  entry  and  output  objects have the correct values.  it should read:      entry: {\n        'main': './src/scripts/main.tsx'\n    },\n    output: {\n        filename: './public/bundle/[name].js',\n        libraryTarget: 'var',\n        library: '[name]'\n    },  This is likely very similar to what is already there.  Simply change  main.ts  to  main.tsx , the filename from  dist  to  public , and remove the  .min  portion of the filename.  Now to test it, run  npm run dev  If you want to run automatically as you're developing, call  npm run watch  If you want to run a minified version of the file, call  npm run min  If it is successful, open the  public/index.html  file in your browser.  Open the browser's console, and you should see  started  printed to the screen.",
            "title": "Building your Project"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#application-state",
            "text": "Cascade stores its data in  Application State  objects.  Depending on what you want to store, they may contain values, other objects, arrays, or even methods to manipulate the data.    Let's say we want to create a  Model  of a  User .  It should store common information for our users, like first and last name.  We also will want to edit it.  So, we start by declaring a class, and adding several properties.  Inside your project, create a folder  src/scripts/models , and inside it a file  User.ts .  export default class User {\n    firstName: string;\n    lastName: string;\n}  Fantastic!  We now have a User class which will correctly store our data!  We have also exported it as default from this file.",
            "title": "Application State"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#components",
            "text": "Cascade displays its data in  Components , which are simply classes that render to the DOM.  They may render Nodes, strings, numbers, nothing, or even other Components.  So, since we have our User model, let's display it!  Inside your project, create a folder  src/scripts/views/user , and inside it a file  UserView.tsx .  First, we must import Cascade into the file.  import Cascade, { Component } from 'cascade';  We have imported Cascade, and the Component class.  While we will not necessarily use the  Cascade  import directly in our code, the JSX interpreter will transpile our JSX statements into Cascade calls.  This process turns what appear to be XML elements into:  Cascade.createElement<T extends Object>(type: string | (new (props: T, ...children: Array<any>) => Component<T>), props: T, ...children: Array<any>): IVirtualNode<T>;`.  Now we must import our User model.  import User from '../../models/User';  We now must define what properties our component takes.  Our component will take in a user.  These appear as XML Attributes in our JSX code.  export interface IUserViewProps {\n    user: User;\n}  Next we need to define our component itself.  export default class UserView extends Component<IUserViewProps> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n            </div>\n        );\n    }\n}  This component takes in a user, and displays the  firstName  and  lastName  inside to  <p>  elements, wrapped inside one  <div>  element.  There are a couple things to note:   We used the Props interface inside the Component definition.  This provides intellisense both when writing the component, and later when we use it.  We used object destructuring to get  user  from  this.props .  This is a shorthand that is much simpler than  let user = this.props.user; .  It especially comes in handy if you're doing that for multiple properties.  Every component must define a render method, even if it returns nothing.  A component may return exactly one value.  Here we wrapped our multiple  <p>  tags in a single  <div>  tag.  We user the  {}  notation to insert the  user  values into the elements.",
            "title": "Components"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#rendering",
            "text": "We now must render our  Application State  into  Component  and display it to the DOM.  Inside the  main.tsx  we must import all of our files, and then render them.  import Cascade from 'cascade'\n\nimport User from './models/User';\nimport UserView from './views/UserView';\n\nwindow.onload = function () {\n    var user = new User();\n    user.firstName = 'First';\n    user.lastName = 'Last';\n\n    Cascade.render(\n        document.getElementById('root'),\n        <UserView user={User} />\n    );\n};  There are a couple things to note:   We imported Cascade, our  User , and our  UserView .  We write our code inside the onload function to ensure it runs after everything is ready.  We create a new user and set the first and last name properties.  We get the  root  element from the DOM  We create a new  UserView  with JSX, pass in the user.  We pass the  root  element and the  UserView  to  Cascade.render() .   Now build the project and run the HTML file in your browser.  It should display your user in the HTML you specified.",
            "title": "Rendering"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/",
            "text": "We've successfully created a working Application.  When we run it, data is presented to the browser as intended.  But what happens if we want to change the data?  Currently, if we change the model, nothing.  Lucky for you, Cascade makes this simple.\n\n\nObservable Properties\n\n\nCascade provides \nObservable\n properties for objects.  Once established, these special properties may be \nsubscribed\n to.  Then, if the value of the property changes, the subscribers will be notified with the updated value.  These special properties can be read and written to exactly like regular properties.\n\n\nWe can use the TypeScript decorator \n@observable\n in the class definition to make a property observable.\n\n\n@observable property: type = value;\n\n\n\n\nIf we don't want to use the decorator, we can attach an observable property to an object with the call:\n\n\nCascade.createObservable<T>(obj: any, property: string, value?: T);\n\n\n\n\nLet's take our \nUser\n example from the last chapter, and make it observable.  So, simply import the \n@observable\n decorator, and add it in front of any properties you want to observe.\n\n\nimport { observable } from 'cascade';\n\nexport default class User {\n    @observable firstName: string;\n    @observable lastName: string;\n}\n\n\n\n\nAnd there we have it!  Our \nfirstName\n and \nlastName\n properties are now Observables!\n\n\nHandling Input\n\n\nNow that we can watch for changes in our data, let's set up some inputs!  \n\n\nexport default class UserView extends Component<IUserViewProps> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n                <p>First name: <input type=\"text\" value={user.firstName} /></p>\n                <p>Last name: <input type=\"text\" value={user.lastName} /></p>\n            </div>\n        );\n    }\n}\n\n\n\n\nThere are a couple of things to note:\n\n\n\n\nWe have included two \n<input>\n tags.\n\n\nWe inject the value using \n{}\n notation.\n\n\n\n\nWhen you run it, you will see your data now displayed in two text fields.  But what happens when you type in the inputs?  Currently, still nothing.\n\n\nCascade works with \none way data binding\n, meaning that changes to data flow from \nApplication State\n to \nComponents\n not the other way around.  This is to prevent \ncircular references\n, where an update moves from A to B to C and so on, but somehow goes back to A.  If that happens, we will end up in an infinite loop.\n\n\nSo, any changes to our \nUser\n will show up in our \nUserView\n, but changes to our \nUserView\n don't automatically go back to our \nUser\n.  In order for that to happen, we need to handle \nEvents\n.\n\n\nAn \nEvent\n is triggered when something happens, like when a user clicks the mouse, or presses a key.  It can even happen when an AJAX call completes.  Normally, a program will execute its instructions until there is nothing left to do, and it will either end, or wait for input.  So, we need to handle that input.\n\n\nFor our \nUserView\n add these two methods above the \nrender\n method.\n\n\nupdateFirstName = (event) => {\n    this.props.user.firstName = event.target.value;\n}\n\nupdateLastName = (event) => {\n    this.props.user.lastName = event.target.value;\n}\n\n\n\n\nThere are a couple of things to note:\n\n\n\n\nThese methods will handle the \nEvent\n, and store the value of the target into our \nUser\n.\n\n\nWe are using the \nArrow Function\n notation, as the \nthis\n value may be changed while executing.\n\n\n\n\nBut how do we hook these handlers up to our inputs?\n\n\n<p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName} /></p>\n\n\n\n\nAnd that's it!  Any time the user updates the text inputs, the \nEvent\n is triggered, and the \nUser\n is updated.\n\n\nWe could also use regular methods instead of Arrow Functions for \nupdateFirstName\n and \nupdateLastName\n.  In that case, when we inject them, we must use \nFunction.bind()\n.\n\n\n<p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName.bind(this)} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName.bind(this)} /></p>\n\n\n\n\nIn many cases, this syntax is harder to read, but it is personal preference.  In some cases, where you must inject a specific value into the method, \nFunction.bind(this, value)\n is useful.\n\n\nRunning our Application\n\n\nSo, we can now display and update our \nUser\n.  Try running it and see what happens!",
            "title": "Updating Data"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#observable-properties",
            "text": "Cascade provides  Observable  properties for objects.  Once established, these special properties may be  subscribed  to.  Then, if the value of the property changes, the subscribers will be notified with the updated value.  These special properties can be read and written to exactly like regular properties.  We can use the TypeScript decorator  @observable  in the class definition to make a property observable.  @observable property: type = value;  If we don't want to use the decorator, we can attach an observable property to an object with the call:  Cascade.createObservable<T>(obj: any, property: string, value?: T);  Let's take our  User  example from the last chapter, and make it observable.  So, simply import the  @observable  decorator, and add it in front of any properties you want to observe.  import { observable } from 'cascade';\n\nexport default class User {\n    @observable firstName: string;\n    @observable lastName: string;\n}  And there we have it!  Our  firstName  and  lastName  properties are now Observables!",
            "title": "Observable Properties"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#handling-input",
            "text": "Now that we can watch for changes in our data, let's set up some inputs!    export default class UserView extends Component<IUserViewProps> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n                <p>First name: <input type=\"text\" value={user.firstName} /></p>\n                <p>Last name: <input type=\"text\" value={user.lastName} /></p>\n            </div>\n        );\n    }\n}  There are a couple of things to note:   We have included two  <input>  tags.  We inject the value using  {}  notation.   When you run it, you will see your data now displayed in two text fields.  But what happens when you type in the inputs?  Currently, still nothing.  Cascade works with  one way data binding , meaning that changes to data flow from  Application State  to  Components  not the other way around.  This is to prevent  circular references , where an update moves from A to B to C and so on, but somehow goes back to A.  If that happens, we will end up in an infinite loop.  So, any changes to our  User  will show up in our  UserView , but changes to our  UserView  don't automatically go back to our  User .  In order for that to happen, we need to handle  Events .  An  Event  is triggered when something happens, like when a user clicks the mouse, or presses a key.  It can even happen when an AJAX call completes.  Normally, a program will execute its instructions until there is nothing left to do, and it will either end, or wait for input.  So, we need to handle that input.  For our  UserView  add these two methods above the  render  method.  updateFirstName = (event) => {\n    this.props.user.firstName = event.target.value;\n}\n\nupdateLastName = (event) => {\n    this.props.user.lastName = event.target.value;\n}  There are a couple of things to note:   These methods will handle the  Event , and store the value of the target into our  User .  We are using the  Arrow Function  notation, as the  this  value may be changed while executing.   But how do we hook these handlers up to our inputs?  <p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName} /></p>  And that's it!  Any time the user updates the text inputs, the  Event  is triggered, and the  User  is updated.  We could also use regular methods instead of Arrow Functions for  updateFirstName  and  updateLastName .  In that case, when we inject them, we must use  Function.bind() .  <p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName.bind(this)} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName.bind(this)} /></p>  In many cases, this syntax is harder to read, but it is personal preference.  In some cases, where you must inject a specific value into the method,  Function.bind(this, value)  is useful.",
            "title": "Handling Input"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#running-our-application",
            "text": "So, we can now display and update our  User .  Try running it and see what happens!",
            "title": "Running our Application"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/",
            "text": "We've looked at creating \nObservable\n properties, which let us watch for changes in our \nApplication State\n.  But how do our \nComponents\n track those changes?\n\n\nIf you look at the \nUserView.render\n method, we simply read from our \nUser\n.  Cascade tracked those changes for us automatically using \nComputed\n properties.  For our Components, this is done behind the scenes.  But we can use them in our Application State just as easily.\n\n\nComputed Properties\n\n\nCascade provides \nComputed\n properties for objects, which use a getter function to produce a value.  However, any \nObservable\n properties used in this function, will automatically produce subscriptions.\n\n\nFor simplicity, we can also use the \n@observable\n decorator, except in front of a getter function.\n\n\n@observable get property(): type {\n    return this.value;\n}\n\n\n\n\nFor our \nUser\n let's add a \nfullName\n \nComputed\n property.  Add this right under the \nfirstName\n and \nlastName\n properties.\n\n\n@observable get fullName() {\n    return this.firstName + ' ' + this.lastName;\n}\n\n\n\n\nThere are a couple things to note:\n\n\n\n\nWe simply used the values in order to subscribe to them automatically.\n\n\nWe can use as many values as we want.\n\n\nWhatever we return from this method will be the value of the property.\n\n\n\n\nSubscribing Directly to Observables\n\n\nThere are two main ways of subscribing to \nObservable\n properties.  We may either subscribe directly, or through a \nComputed\n property, which we will examine next.\n\n\nCascade.subscribe<T>(obj: any, property: string, subscriberFunction: ISubscriberFunction<T>);\n\n\n\n\nThe \nsubscriberFunction\n will be called any time the value of the property changes.  Keep in mind, simply storing an identical value to the property is not a change, and so there will be no notification.\n\n\nHiding Reads\n\n\nAny time a \nComputed\n property references another \nObservable\n property, Cascade will automatically create a subscription.  However, in some cases you may want to read, but not product a subscription.  In this case, read the \nObservable\n with:\n\n\nCascade.peek(obj: any, property: string): any;\n\n\n\n\nUpdate Batching\n\n\nCascade attempts to reduce updates to \nComputed\n properties whenever possible.  For example, lets say we have a some \nApplication State\n with multiple \nObservable\n properties and a \nComputed\n property which references them.  Now let's say we change all of the \nObservable\n properties.  Cascade will only update the \nComputed\n once.\n\n\nclass ViewModel {\n    @observable a: number = 0;\n    @observable b: number = 0;\n    @observable c: number = 0;\n    @computed get abc(): number {\n        return this.a + this.b + this.c;\n    }\n}\n\n// Create our Application State\nlet viewModel = new ViewModel();\n\n// Subscribe to our Computed\nCascade.subscribe(viewModel, 'abc', (value) => {\n    console.log(viewModel.abc);\n});\n\n// Update our values\nviewModel.a = 1;\nviewModel.b = 2;\nviewModel.c = 3;\n\n\n\n\nIn the example above, our \nconsole.log()\n will only be called twice.\n\n\nAvoid Circular References\n\n\nIn order for updates to flow, we must avoid any \"circular references\" or \"cycles\".  This means that as an update is occurring, it must not reach the same node more than once.\n\n\nFor example, let's say we have two \nComputed\n properties, A and B.  And let's say A references B, and B references A.  So if A is updated, then we must update B.  Similarly if B is updated, we must update A.  In which case updating A, will update B, which will update A, which will update B, and so on.\n\n\nSo it is important that these situations be avoided.\n\n\nResponding to updates\n\n\nIt is best to avoid writing to \nObservable\n properties inside of a \nComputed\n.  In most cases, a second \nComputed\n which references the first will be enough.\n\n\n\n\nNote: absolutely do not both read and write to an Observable inside of a Computed.  This will cause a circular reference.\n\n\n\n\nIf you must write to an \nObservable\n or do other work, it is best to wrap it inside of a \nwindow.setTimeout()\n, or use:\n\n\nCascade.wrapContext(callback: () => any, thisArg?: any): IObservable<any[]>;",
            "title": "Computed Properties"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#computed-properties",
            "text": "Cascade provides  Computed  properties for objects, which use a getter function to produce a value.  However, any  Observable  properties used in this function, will automatically produce subscriptions.  For simplicity, we can also use the  @observable  decorator, except in front of a getter function.  @observable get property(): type {\n    return this.value;\n}  For our  User  let's add a  fullName   Computed  property.  Add this right under the  firstName  and  lastName  properties.  @observable get fullName() {\n    return this.firstName + ' ' + this.lastName;\n}  There are a couple things to note:   We simply used the values in order to subscribe to them automatically.  We can use as many values as we want.  Whatever we return from this method will be the value of the property.",
            "title": "Computed Properties"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#subscribing-directly-to-observables",
            "text": "There are two main ways of subscribing to  Observable  properties.  We may either subscribe directly, or through a  Computed  property, which we will examine next.  Cascade.subscribe<T>(obj: any, property: string, subscriberFunction: ISubscriberFunction<T>);  The  subscriberFunction  will be called any time the value of the property changes.  Keep in mind, simply storing an identical value to the property is not a change, and so there will be no notification.",
            "title": "Subscribing Directly to Observables"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#hiding-reads",
            "text": "Any time a  Computed  property references another  Observable  property, Cascade will automatically create a subscription.  However, in some cases you may want to read, but not product a subscription.  In this case, read the  Observable  with:  Cascade.peek(obj: any, property: string): any;",
            "title": "Hiding Reads"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#update-batching",
            "text": "Cascade attempts to reduce updates to  Computed  properties whenever possible.  For example, lets say we have a some  Application State  with multiple  Observable  properties and a  Computed  property which references them.  Now let's say we change all of the  Observable  properties.  Cascade will only update the  Computed  once.  class ViewModel {\n    @observable a: number = 0;\n    @observable b: number = 0;\n    @observable c: number = 0;\n    @computed get abc(): number {\n        return this.a + this.b + this.c;\n    }\n}\n\n// Create our Application State\nlet viewModel = new ViewModel();\n\n// Subscribe to our Computed\nCascade.subscribe(viewModel, 'abc', (value) => {\n    console.log(viewModel.abc);\n});\n\n// Update our values\nviewModel.a = 1;\nviewModel.b = 2;\nviewModel.c = 3;  In the example above, our  console.log()  will only be called twice.",
            "title": "Update Batching"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#avoid-circular-references",
            "text": "In order for updates to flow, we must avoid any \"circular references\" or \"cycles\".  This means that as an update is occurring, it must not reach the same node more than once.  For example, let's say we have two  Computed  properties, A and B.  And let's say A references B, and B references A.  So if A is updated, then we must update B.  Similarly if B is updated, we must update A.  In which case updating A, will update B, which will update A, which will update B, and so on.  So it is important that these situations be avoided.",
            "title": "Avoid Circular References"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#responding-to-updates",
            "text": "It is best to avoid writing to  Observable  properties inside of a  Computed .  In most cases, a second  Computed  which references the first will be enough.   Note: absolutely do not both read and write to an Observable inside of a Computed.  This will cause a circular reference.   If you must write to an  Observable  or do other work, it is best to wrap it inside of a  window.setTimeout() , or use:  Cascade.wrapContext(callback: () => any, thisArg?: any): IObservable<any[]>;",
            "title": "Responding to updates"
        },
        {
            "location": "/0-Overview/0.4-Handling-Events/",
            "text": "The DOM has built-in support for \nEvent-Driven\n programming.  This means your application can sit around and wait for user input or other \nEvents\n.  Once an \nEvent\n has occurred, its information is sent to a function called an \nEventListener\n.\n\n\nWe saw an example of this during the last section for handling \nchange\n events from \n<input>\n elements.  \n\n\nEvent Listeners\n\n\nUsing classical JavaScript \nDOM Element Attributes\n\n\n/* Code */\nfunction handleClick() {\n    ...\n}\n\n/* View */\n<button onclick=\"handleClick()\" />\n\n\n\n\nUsing JSX to inject \nEventListeners\n.\n\n\n/* Code */\nclass ViewModel {\n    handleClick() {\n        ...\n    }\n}\n\n/* View */\n<button onclick={viewModel.handleClick.bind(this)} />\n\n\n\n\nUsing TypeScript arrow methods to simplify syntax.\n\n\n/* Code */\nclass ViewModel {\n    handleClick = () => {\n        ...\n    }\n}\n\n/* View */\n<button onclick={viewModel.handleClick} />\n\n\n\n\nAsynchronous Programming\n\n\nJavaScript can be written as \nasynchronous\n code, meaning it doesn't have to always run in order.  Most of the time this isn't the case, as instructions are executed one after another.\n\n\nEvent Propagation\n\n\nEvent.stopPropagation();\nEvent.preventDefault();",
            "title": "Handling Events"
        },
        {
            "location": "/0-Overview/0.4-Handling-Events/#event-listeners",
            "text": "Using classical JavaScript  DOM Element Attributes  /* Code */\nfunction handleClick() {\n    ...\n}\n\n/* View */\n<button onclick=\"handleClick()\" />  Using JSX to inject  EventListeners .  /* Code */\nclass ViewModel {\n    handleClick() {\n        ...\n    }\n}\n\n/* View */\n<button onclick={viewModel.handleClick.bind(this)} />  Using TypeScript arrow methods to simplify syntax.  /* Code */\nclass ViewModel {\n    handleClick = () => {\n        ...\n    }\n}\n\n/* View */\n<button onclick={viewModel.handleClick} />",
            "title": "Event Listeners"
        },
        {
            "location": "/0-Overview/0.4-Handling-Events/#asynchronous-programming",
            "text": "JavaScript can be written as  asynchronous  code, meaning it doesn't have to always run in order.  Most of the time this isn't the case, as instructions are executed one after another.",
            "title": "Asynchronous Programming"
        },
        {
            "location": "/0-Overview/0.4-Handling-Events/#event-propagation",
            "text": "Event.stopPropagation();\nEvent.preventDefault();",
            "title": "Event Propagation"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/",
            "text": "JavaScript supports two basic data structures for storing information, Arrays and Hashes.  Let's look at how we might add an Array and a Hash to a View Model.\n\n\nArrays\n\n\nTypeScript arrays can be defined and initialized in two ways, with the \nArray<T>\n type, or \nT[]\n type.  Both of these are equivalent, but one or the other may be easier to write depending on the situation.  Also, for compatibility with Internet Explorer, Cascade provides an interface \nIArray<T>\n, but we will cover that in more depth later.\n\n\nSo, if we were to create an Array of \nstring\n elements, it would be.\n\n\nlet list: string[] = [];\n\n\n\n\nThis code simply creates an variable called \nlist\n, defined as an \nstring[]\n and initializes it to be an empty \nArray\n.  It is important to note that we have initialized this variable, otherwise it would equal \nundefined\n.\n\n\nNow that we have created an \nArray\n, we can access its values with a regular \nAssignment Operator\n.  We can read and write values with:\n\n\nlet value = list[0];\nlist[1] = 2;\n\n\n\n\nWe can also use any of the \nArray\n methods, such as \nArray.prototype.push(value: any): void;\n\n\nlist.push(3);\n\n\n\n\nHashes\n\n\nNext, we have JavaScript Hashes, which are actually just regular Objects.\n\n\nTypeScript Hashes can be defined as an \ninterface\n, which stores elements with either \nstring\n or \nnumber\n indexes.  JavaScript allows for mixing index types, but TypeScript requies it to be one or the other.  Since we already have support for \nnumber\n indexes with Arrays, Cascade defines Hash types as:\n\n\ninterface IHash<T> {\n    [index: string]: T;\n}\n\n\n\n\nFor ease of use, \nIHash\n may be imported from Cascade.\n\n\nExternal Links\n\n\nFor more information on Arrays, visit \nArray - JavaScript | MDN\n\n\nFor more information on Objects, visit \nObjects - JavaScript | MDN\n\n\nView Models\n\n\nWe may store Arrays and Hashes as properties on a View Model.  For example:\n\n\nclass ViewModel {\n    list = [];\n    map = {};\n}\n\n\n\n\nHowever, just like regular properties, changes to these properties will be ignored.  Again, if we add our decorators, we can subscribe to changes.\n\n\nclass ViewModel {\n    @array list = [];\n    @hash map = {};\n}\n\n\n\n\nIt's important to note that once an Array or Hashe is marked as observable, Cascade will automatically set its value to be an Array or Hash, even if we haven't initialized it.  We don't even have to write an initialization in the code.  Plus, we don't have to check if the property is truthy before doing lookups on it.  All of that is handled by Cascade!\n\n\nSo, we can simply write:\n\n\nclass ViewModel {\n    @array list;\n    @hash map;\n}\n\n\n\n\nWe can also be more specific about what is stored in Arrays and Hashes.\n\n\nclass ViewModel {\n    @array list: string[];\n    @hash map: IHash<string>;\n}\n\n\n\n\nReflection Polyfill\n\n\nBy default, Arrays must be decorated with \n@array\n and Hashes with \n@hash\n.  However, just like we can use \n@observable\n to decorate \nComputed\n properties, we can also use it to decorate Arrays, but only with some extra libraries.\n\n\nIn order to get this automatic type detection, we have to set up an experimental TypeScript Metadata feature.  First off, you must set \n\"emitDecoratorMetadata\": true\n in your \ntsconfig.json\n file.  Then, you must install the package \nreflect-metadata\n from npm.\n\n\nFurthermore, for IE10 and below, you must also include \nes6-shim\n or similar polyfills.\n\n\nThen, in your main TypeScript file, you must include:\n\n\nimport 'es6-shim';\nimport 'reflect-metadata';\n\n\n\n\n\n\nNote:\n This does not currently support Hashes.\n\n\n\n\nLegacy Browser Support\n\n\nIn general, Cascade fully supports older browsers, including Internet Explorer 9+.  However, Arrays and Hashes are one area where some special consideration must be made.\n\n\nFirst off, Observable Hashes are not supported.  Their functionality can be emulated easily with ObservableArrays and a regular Hash object.\n\n\nSecondly, Observable Arrays work slightly differently in Internet Explorer.  In modern browsers, we can simply write to any index and it will be detected.\n\n\nviewModel.list[0] = 'value';\n\n\n\n\nHowever, in Internet Explorer, we must use an explicit setter method.\n\n\nObserableArray<T>.set(index: number, value: T): void;\n\n\n\n\nWhich in practice would look like:\n\n\nviewModel.list.set(0, 'value');\n\n\n\n\nHowever, TypeScript will complain that the \nset\n method doesn't exist on \nArray\n.  So, we can update our View Model to use \nIArray<T>\n instead of \nT[]\n or \nArray<T>\n.  This interface can be imported from Cascade.\n\n\nclass ViewModel {\n    @array list: IArray<string>;\n    @hash map: IHash<string>;\n}",
            "title": "Arrays and Hashes"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#arrays",
            "text": "TypeScript arrays can be defined and initialized in two ways, with the  Array<T>  type, or  T[]  type.  Both of these are equivalent, but one or the other may be easier to write depending on the situation.  Also, for compatibility with Internet Explorer, Cascade provides an interface  IArray<T> , but we will cover that in more depth later.  So, if we were to create an Array of  string  elements, it would be.  let list: string[] = [];  This code simply creates an variable called  list , defined as an  string[]  and initializes it to be an empty  Array .  It is important to note that we have initialized this variable, otherwise it would equal  undefined .  Now that we have created an  Array , we can access its values with a regular  Assignment Operator .  We can read and write values with:  let value = list[0];\nlist[1] = 2;  We can also use any of the  Array  methods, such as  Array.prototype.push(value: any): void;  list.push(3);",
            "title": "Arrays"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#hashes",
            "text": "Next, we have JavaScript Hashes, which are actually just regular Objects.  TypeScript Hashes can be defined as an  interface , which stores elements with either  string  or  number  indexes.  JavaScript allows for mixing index types, but TypeScript requies it to be one or the other.  Since we already have support for  number  indexes with Arrays, Cascade defines Hash types as:  interface IHash<T> {\n    [index: string]: T;\n}  For ease of use,  IHash  may be imported from Cascade.",
            "title": "Hashes"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#external-links",
            "text": "For more information on Arrays, visit  Array - JavaScript | MDN  For more information on Objects, visit  Objects - JavaScript | MDN",
            "title": "External Links"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#view-models",
            "text": "We may store Arrays and Hashes as properties on a View Model.  For example:  class ViewModel {\n    list = [];\n    map = {};\n}  However, just like regular properties, changes to these properties will be ignored.  Again, if we add our decorators, we can subscribe to changes.  class ViewModel {\n    @array list = [];\n    @hash map = {};\n}  It's important to note that once an Array or Hashe is marked as observable, Cascade will automatically set its value to be an Array or Hash, even if we haven't initialized it.  We don't even have to write an initialization in the code.  Plus, we don't have to check if the property is truthy before doing lookups on it.  All of that is handled by Cascade!  So, we can simply write:  class ViewModel {\n    @array list;\n    @hash map;\n}  We can also be more specific about what is stored in Arrays and Hashes.  class ViewModel {\n    @array list: string[];\n    @hash map: IHash<string>;\n}",
            "title": "View Models"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#reflection-polyfill",
            "text": "By default, Arrays must be decorated with  @array  and Hashes with  @hash .  However, just like we can use  @observable  to decorate  Computed  properties, we can also use it to decorate Arrays, but only with some extra libraries.  In order to get this automatic type detection, we have to set up an experimental TypeScript Metadata feature.  First off, you must set  \"emitDecoratorMetadata\": true  in your  tsconfig.json  file.  Then, you must install the package  reflect-metadata  from npm.  Furthermore, for IE10 and below, you must also include  es6-shim  or similar polyfills.  Then, in your main TypeScript file, you must include:  import 'es6-shim';\nimport 'reflect-metadata';   Note:  This does not currently support Hashes.",
            "title": "Reflection Polyfill"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#legacy-browser-support",
            "text": "In general, Cascade fully supports older browsers, including Internet Explorer 9+.  However, Arrays and Hashes are one area where some special consideration must be made.  First off, Observable Hashes are not supported.  Their functionality can be emulated easily with ObservableArrays and a regular Hash object.  Secondly, Observable Arrays work slightly differently in Internet Explorer.  In modern browsers, we can simply write to any index and it will be detected.  viewModel.list[0] = 'value';  However, in Internet Explorer, we must use an explicit setter method.  ObserableArray<T>.set(index: number, value: T): void;  Which in practice would look like:  viewModel.list.set(0, 'value');  However, TypeScript will complain that the  set  method doesn't exist on  Array .  So, we can update our View Model to use  IArray<T>  instead of  T[]  or  Array<T> .  This interface can be imported from Cascade.  class ViewModel {\n    @array list: IArray<string>;\n    @hash map: IHash<string>;\n}",
            "title": "Legacy Browser Support"
        },
        {
            "location": "/1-Reactive-Programming/1.0-Computed-Chains/",
            "text": "Cascade uses \nobservable\n and \ncomputed\n properties to synchronize data across its Objects.  To do this, it uses a form of \nReactive Programming\n, in which values across the data structure are linked together.  So if a value is changed in one portion, other portions might \nReact\n and update themselves.\n\n\nComputed Properties\n\n\nA \ncomputed\n property is merely a function which runs to calculate a value.  However, if the \ncomputed\n references an \nobservable\n property, and that property is updated, the \ncomputed\n will be run again.\n\n\nPush Updates\n\n\nWhen an \nobservable\n updates, its values is pushed to its subscribers.  However, those subscribers then wait for all changes to be, so that updates can be processed all at once.\n\n\nPull Updates\n\n\nWhen an \ncomputed\n has been marked dirty, and something needs its value immediately, it will be calculated immediately.",
            "title": "Computed Chains"
        },
        {
            "location": "/1-Reactive-Programming/1.0-Computed-Chains/#computed-properties",
            "text": "A  computed  property is merely a function which runs to calculate a value.  However, if the  computed  references an  observable  property, and that property is updated, the  computed  will be run again.",
            "title": "Computed Properties"
        },
        {
            "location": "/1-Reactive-Programming/1.0-Computed-Chains/#push-updates",
            "text": "When an  observable  updates, its values is pushed to its subscribers.  However, those subscribers then wait for all changes to be, so that updates can be processed all at once.",
            "title": "Push Updates"
        },
        {
            "location": "/1-Reactive-Programming/1.0-Computed-Chains/#pull-updates",
            "text": "When an  computed  has been marked dirty, and something needs its value immediately, it will be calculated immediately.",
            "title": "Pull Updates"
        }
    ]
}