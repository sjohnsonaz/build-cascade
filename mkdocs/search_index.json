{
    "docs": [
        {
            "location": "/",
            "text": "Cascade\n\n\nA modern library for creating user interfaces\n\n\nWritten for JavaScript and TypeScript, Cascade is a complete framework for displaying and synchronizing application data.\n\n\nUsing modern techniques, the framework simply \n\"gets out of your way\"\n.  You simply set up your \nApplication State\n, display it in a \nComponent\n, and Cascade handles the rest.  If you update the data, the DOM is automatically updated as well!\n\n\nPlus, using careful dependency tracking, updates are planned for maximum efficiency!\n\n\nGetting a Cascade application going is super easy!\n\n\n/* Import Cascade */\nimport Cascade, { Component, observable } from 'cascade';\n\n/* Define your Application State */\nclass ApplicationState {\n    @observable value = 'Some value';\n}\n\n/* Define your Component Props */\ninterface IViewProps {\n    applicationState: ApplicationState;\n}\n\n/* Define your Component */\nclass View extends Component<IViewProps> {\n    render() {\n        let { applicationState } = this.props;\n        return (\n            <div>{applicationState.value}</div>\n        );\n    }\n}\n\n/* Render your Application */\nlet applicationState = new ApplicationState();\nCascade.render(document.body, <View applicationState={applicationState} />);\n\n/* Update your Application State */\napplicationState.value = 'Some NEW value';\n\n\n\n\nSo go ahead and \nget started\n!",
            "title": "Home"
        },
        {
            "location": "/#cascade",
            "text": "",
            "title": "Cascade"
        },
        {
            "location": "/#a-modern-library-for-creating-user-interfaces",
            "text": "Written for JavaScript and TypeScript, Cascade is a complete framework for displaying and synchronizing application data.  Using modern techniques, the framework simply  \"gets out of your way\" .  You simply set up your  Application State , display it in a  Component , and Cascade handles the rest.  If you update the data, the DOM is automatically updated as well!  Plus, using careful dependency tracking, updates are planned for maximum efficiency!  Getting a Cascade application going is super easy!  /* Import Cascade */\nimport Cascade, { Component, observable } from 'cascade';\n\n/* Define your Application State */\nclass ApplicationState {\n    @observable value = 'Some value';\n}\n\n/* Define your Component Props */\ninterface IViewProps {\n    applicationState: ApplicationState;\n}\n\n/* Define your Component */\nclass View extends Component<IViewProps> {\n    render() {\n        let { applicationState } = this.props;\n        return (\n            <div>{applicationState.value}</div>\n        );\n    }\n}\n\n/* Render your Application */\nlet applicationState = new ApplicationState();\nCascade.render(document.body, <View applicationState={applicationState} />);\n\n/* Update your Application State */\napplicationState.value = 'Some NEW value';  So go ahead and  get started !",
            "title": "A modern library for creating user interfaces"
        },
        {
            "location": "/Tutorials/0.0-Getting-Started/",
            "text": "Using Cascade requires only a few steps.  It's designed for TypeScript, but is completely compatible with pure JavaScript.\n\n\nInstalling TypeScript\n\n\nFor simplicity in these tutorials, you can download a simple boilerplate at \nhttps://github.com/sjohnsonaz/ts-boilerplate\n.  Follow its instructions to get a TypeScript environment up and running.  Otherwise, you will need to set up Node, TypeScript, and Webpack to compile and run these projects.\n\n\nInstalling Cascade\n\n\nFor TypeScript, it is recommended to install Cascade via npm.  It should be installed as a \"dependency\" for most projects, unless you're creating a shared library.  Shared libraries should install Cascade as a \"peerDependency\".\n\n\nnpm install cascade --save\n\n\n\nCascade can also be downloaded from \nhttps://github.com/sjohnsonaz/cascade/releases\n.",
            "title": "Getting Started"
        },
        {
            "location": "/Tutorials/0.0-Getting-Started/#installing-typescript",
            "text": "For simplicity in these tutorials, you can download a simple boilerplate at  https://github.com/sjohnsonaz/ts-boilerplate .  Follow its instructions to get a TypeScript environment up and running.  Otherwise, you will need to set up Node, TypeScript, and Webpack to compile and run these projects.",
            "title": "Installing TypeScript"
        },
        {
            "location": "/Tutorials/0.0-Getting-Started/#installing-cascade",
            "text": "For TypeScript, it is recommended to install Cascade via npm.  It should be installed as a \"dependency\" for most projects, unless you're creating a shared library.  Shared libraries should install Cascade as a \"peerDependency\".  npm install cascade --save  Cascade can also be downloaded from  https://github.com/sjohnsonaz/cascade/releases .",
            "title": "Installing Cascade"
        },
        {
            "location": "/Tutorials/0.1-Displaying-Data/",
            "text": "In this tutorial, we take a look at Cascade, what it can do, and the fundamental parts of any Cascade project.  You should already have a TypeScript environment running, and have included Cascade in your project dependencies.\n\n\nProject Organization\n\n\nAny Cascade project includes \nApplication State\n and \nComponents\n.  This is similar to many common patterns such as \nMVC\n or \nMVVM\n, where you have a distinct separation between your data, and how you display it.  Ultimately, the specifics of your pattern are up to you, but the overal concept is the same.  We will introduce some common patterns in later tutorials.\n\n\nBefore we get started, your TypeScript project should have a \ntsconfig.json\n file.  Open this file, and ensure the following options are set:\n\n\n\"jsx\": \"react\",\n\"reactNamespace\": \"Cascade\",\n\"experimentalDecorators\": true,\n\"emitDecoratorMetadata\": true\n\n\n\n\nThe \nemitDecoratorMetadata\n value is optional, as we will see later.\n\n\nAlso, ensure that you have \nsrc\n and \npublic\n directories in your project.\n\n\nBuilding your Project\n\n\nIt will be easier to develop our project if we can run it.  Let's start by setting up a simple set of files and getting the to build.\n\n\nInside the \npublic\n directory, create a file \nindex.html\n.  This will be the main HTML file that runs the project.\n\n\n<!DOCTYPE>\n<html>\n\n<head>\n    <title>Tutorial 0</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n    <script src=\"bundle/main.js\" type=\"text/javascript\"></script>\n</body>\n\n</html>\n\n\n\n\nThis file creates a \n<div>\n to mount our component, and then loads the script.  Note that we're loading our script from \nbundle/main.js\n, which is a file that doesn't currently exist.  We are going to build it later.\n\n\nInside the \nsrc/scripts\n directory, create a file \nmain.tsx\n.\n\n\nwindow.onload = function () {\n    console.log('started');\n}\n\n\n\n\nWe now must set up Webpack to build our \nmain.tsx\n file.  Inside the webpack configs (there are two if you're using the ts-boilerplate), ensure that the \nentry\n and \noutput\n objects have the correct values.  it should read:\n\n\n    entry: {\n        'main': './src/scripts/main.tsx'\n    },\n    output: {\n        filename: './public/bundle/[name].js',\n        libraryTarget: 'var',\n        library: '[name]'\n    },\n\n\n\n\nThis is likely very similar to what is already there.  Simply change \nmain.ts\n to \nmain.tsx\n, the filename from \ndist\n to \npublic\n, and remove the \n.min\n portion of the filename.\n\n\nNow to test it, run\n\n\nnpm run dev\n\n\n\nIf you want to run automatically as you're developing, call\n\n\nnpm run watch\n\n\n\nIf you want to run a minified version of the file, call\n\n\nnpm run min\n\n\n\nIf it is successful, open the \npublic/index.html\n file in your browser.  Open the browser's console, and you should see \nstarted\n printed to the screen.\n\n\nApplication State\n\n\nCascade stores its data in \nApplication State\n objects.  Depending on what you want to store, they may contain values, other objects, arrays, or even methods to manipulate the data.  \n\n\nLet's say we want to create a \nModel\n of a \nUser\n.  It should store common information for our users, like first and last name.  We also will want to edit it.\n\n\nSo, we start by declaring a class, and adding several properties.  Inside your project, create a folder \nsrc/scripts/models\n, and inside it a file \nUser.ts\n.\n\n\nexport default class User {\n    firstName: string;\n    lastName: string;\n}\n\n\n\n\nFantastic!  We now have a User class which will correctly store our data!  We have also exported it as default from this file.\n\n\nComponents\n\n\nCascade displays its data in \nComponents\n, which are simply classes that render to the DOM.  They may render Nodes, strings, numbers, nothing, or even other Components.\n\n\nSo, since we have our User model, let's display it!  Inside your project, create a folder \nsrc/scripts/views/user\n, and inside it a file \nUserView.tsx\n.\n\n\nFirst, we must import Cascade into the file.\n\n\nimport Cascade, { Component } from 'cascade';\n\n\n\n\nWe have imported Cascade, and the Component class.  While we will not necessarily use the \nCascade\n import directly in our code, the JSX interpreter will transpile our JSX statements into Cascade calls.  This process turns what appear to be XML elements into:\n\n\nCascade.createElement<T extends Object>(type: string | (new (props: T, ...children: Array<any>) => Component<T>), props: T, ...children: Array<any>): IVirtualNode<T>;`.\n\n\n\n\nNow we must import our User model.\n\n\nimport User from '../../models/User';\n\n\n\n\nWe now must define what properties our component takes.  Our component will take in a user.  These appear as XML Attributes in our JSX code.\n\n\nexport interface IUserViewProps {\n    user: User;\n}\n\n\n\n\nNext we need to define our component itself.\n\n\nexport default class UserView extends Component<IUserViewProps> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n            </div>\n        );\n    }\n}\n\n\n\n\nThis component takes in a user, and displays the \nfirstName\n and \nlastName\n inside to \n<p>\n elements, wrapped inside one \n<div>\n element.\n\n\nThere are a couple things to note:\n\n\n\n\nWe used the Props interface inside the Component definition.  This provides intellisense both when writing the component, and later when we use it.\n\n\nWe used object destructuring to get \nuser\n from \nthis.props\n.  This is a shorthand that is much simpler than \nlet user = this.props.user;\n.  It especially comes in handy if you're doing that for multiple properties.\n\n\nEvery component must define a render method, even if it returns nothing.\n\n\nA component may return exactly one value.  Here we wrapped our multiple \n<p>\n tags in a single \n<div>\n tag.\n\n\nWe user the \n{}\n notation to insert the \nuser\n values into the elements.\n\n\n\n\nRendering\n\n\nWe now must render our \nApplication State\n into \nComponent\n and display it to the DOM.\n\n\nInside the \nmain.tsx\n we must import all of our files, and then render them.\n\n\nimport Cascade from 'cascade'\n\nimport User from './models/User';\nimport UserView from './views/UserView';\n\nwindow.onload = function () {\n    var user = new User();\n    user.firstName = 'First';\n    user.lastName = 'Last';\n\n    Cascade.render(\n        document.getElementById('root'),\n        <UserView user={User} />\n    );\n};\n\n\n\n\nThere are a couple things to note:\n\n\n\n\nWe imported Cascade, our \nUser\n, and our \nUserView\n.\n\n\nWe write our code inside the onload function to ensure it runs after everything is ready.\n\n\nWe create a new user and set the first and last name properties.\n\n\nWe get the \nroot\n element from the DOM\n\n\nWe create a new \nUserView\n with JSX, pass in the user.\n\n\nWe pass the \nroot\n element and the \nUserView\n to \nCascade.render()\n.\n\n\n\n\nNow build the project and run the HTML file in your browser.  It should display your user in the HTML you specified.",
            "title": "Displaying Data"
        },
        {
            "location": "/Tutorials/0.1-Displaying-Data/#project-organization",
            "text": "Any Cascade project includes  Application State  and  Components .  This is similar to many common patterns such as  MVC  or  MVVM , where you have a distinct separation between your data, and how you display it.  Ultimately, the specifics of your pattern are up to you, but the overal concept is the same.  We will introduce some common patterns in later tutorials.  Before we get started, your TypeScript project should have a  tsconfig.json  file.  Open this file, and ensure the following options are set:  \"jsx\": \"react\",\n\"reactNamespace\": \"Cascade\",\n\"experimentalDecorators\": true,\n\"emitDecoratorMetadata\": true  The  emitDecoratorMetadata  value is optional, as we will see later.  Also, ensure that you have  src  and  public  directories in your project.",
            "title": "Project Organization"
        },
        {
            "location": "/Tutorials/0.1-Displaying-Data/#building-your-project",
            "text": "It will be easier to develop our project if we can run it.  Let's start by setting up a simple set of files and getting the to build.  Inside the  public  directory, create a file  index.html .  This will be the main HTML file that runs the project.  <!DOCTYPE>\n<html>\n\n<head>\n    <title>Tutorial 0</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n    <script src=\"bundle/main.js\" type=\"text/javascript\"></script>\n</body>\n\n</html>  This file creates a  <div>  to mount our component, and then loads the script.  Note that we're loading our script from  bundle/main.js , which is a file that doesn't currently exist.  We are going to build it later.  Inside the  src/scripts  directory, create a file  main.tsx .  window.onload = function () {\n    console.log('started');\n}  We now must set up Webpack to build our  main.tsx  file.  Inside the webpack configs (there are two if you're using the ts-boilerplate), ensure that the  entry  and  output  objects have the correct values.  it should read:      entry: {\n        'main': './src/scripts/main.tsx'\n    },\n    output: {\n        filename: './public/bundle/[name].js',\n        libraryTarget: 'var',\n        library: '[name]'\n    },  This is likely very similar to what is already there.  Simply change  main.ts  to  main.tsx , the filename from  dist  to  public , and remove the  .min  portion of the filename.  Now to test it, run  npm run dev  If you want to run automatically as you're developing, call  npm run watch  If you want to run a minified version of the file, call  npm run min  If it is successful, open the  public/index.html  file in your browser.  Open the browser's console, and you should see  started  printed to the screen.",
            "title": "Building your Project"
        },
        {
            "location": "/Tutorials/0.1-Displaying-Data/#application-state",
            "text": "Cascade stores its data in  Application State  objects.  Depending on what you want to store, they may contain values, other objects, arrays, or even methods to manipulate the data.    Let's say we want to create a  Model  of a  User .  It should store common information for our users, like first and last name.  We also will want to edit it.  So, we start by declaring a class, and adding several properties.  Inside your project, create a folder  src/scripts/models , and inside it a file  User.ts .  export default class User {\n    firstName: string;\n    lastName: string;\n}  Fantastic!  We now have a User class which will correctly store our data!  We have also exported it as default from this file.",
            "title": "Application State"
        },
        {
            "location": "/Tutorials/0.1-Displaying-Data/#components",
            "text": "Cascade displays its data in  Components , which are simply classes that render to the DOM.  They may render Nodes, strings, numbers, nothing, or even other Components.  So, since we have our User model, let's display it!  Inside your project, create a folder  src/scripts/views/user , and inside it a file  UserView.tsx .  First, we must import Cascade into the file.  import Cascade, { Component } from 'cascade';  We have imported Cascade, and the Component class.  While we will not necessarily use the  Cascade  import directly in our code, the JSX interpreter will transpile our JSX statements into Cascade calls.  This process turns what appear to be XML elements into:  Cascade.createElement<T extends Object>(type: string | (new (props: T, ...children: Array<any>) => Component<T>), props: T, ...children: Array<any>): IVirtualNode<T>;`.  Now we must import our User model.  import User from '../../models/User';  We now must define what properties our component takes.  Our component will take in a user.  These appear as XML Attributes in our JSX code.  export interface IUserViewProps {\n    user: User;\n}  Next we need to define our component itself.  export default class UserView extends Component<IUserViewProps> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n            </div>\n        );\n    }\n}  This component takes in a user, and displays the  firstName  and  lastName  inside to  <p>  elements, wrapped inside one  <div>  element.  There are a couple things to note:   We used the Props interface inside the Component definition.  This provides intellisense both when writing the component, and later when we use it.  We used object destructuring to get  user  from  this.props .  This is a shorthand that is much simpler than  let user = this.props.user; .  It especially comes in handy if you're doing that for multiple properties.  Every component must define a render method, even if it returns nothing.  A component may return exactly one value.  Here we wrapped our multiple  <p>  tags in a single  <div>  tag.  We user the  {}  notation to insert the  user  values into the elements.",
            "title": "Components"
        },
        {
            "location": "/Tutorials/0.1-Displaying-Data/#rendering",
            "text": "We now must render our  Application State  into  Component  and display it to the DOM.  Inside the  main.tsx  we must import all of our files, and then render them.  import Cascade from 'cascade'\n\nimport User from './models/User';\nimport UserView from './views/UserView';\n\nwindow.onload = function () {\n    var user = new User();\n    user.firstName = 'First';\n    user.lastName = 'Last';\n\n    Cascade.render(\n        document.getElementById('root'),\n        <UserView user={User} />\n    );\n};  There are a couple things to note:   We imported Cascade, our  User , and our  UserView .  We write our code inside the onload function to ensure it runs after everything is ready.  We create a new user and set the first and last name properties.  We get the  root  element from the DOM  We create a new  UserView  with JSX, pass in the user.  We pass the  root  element and the  UserView  to  Cascade.render() .   Now build the project and run the HTML file in your browser.  It should display your user in the HTML you specified.",
            "title": "Rendering"
        },
        {
            "location": "/Tutorials/0.2-Updating-Data/",
            "text": "We've successfully created a working Application.  When we run it, data is presented to the browser as intended.  But what happens if we want to change the data?  Currently, if we change the model, nothing.  Lucky for you, Cascade makes this simple.\n\n\nObservable Properties\n\n\nCascade provides \nObservable\n properties for objects.  Once established, these special properties may be \nsubscribed\n to.  Then, if the value of the property changes, the subscribers will be notified with the updated value.  These special properties can be read and written to exactly like regular properties.\n\n\nWe can use the TypeScript decorator \n@observable\n in the class definition to make a property observable.\n\n\n@observable property: type = value;\n\n\n\n\nIf we don't want to use the decorator, we can attach an observable property to an object with the call:\n\n\nCascade.createObservable<T>(obj: any, property: string, value?: T);\n\n\n\n\nLet's take our \nUser\n example from the last chapter, and make it observable.  So, simply import the \n@observable\n decorator, and add it in front of any properties you want to observe.\n\n\nimport { observable } from 'cascade';\n\nexport default class User {\n    @observable firstName: string;\n    @observable lastName: string;\n}\n\n\n\n\nAnd there we have it!  Our \nfirstName\n and \nlastName\n properties are now Observables!\n\n\nHandling Input\n\n\nNow that we can watch for changes in our data, let's set up some inputs!  \n\n\nexport default class UserView extends Component<IUserViewProps> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n                <p>First name: <input type=\"text\" value={user.firstName} /></p>\n                <p>Last name: <input type=\"text\" value={user.lastName} /></p>\n            </div>\n        );\n    }\n}\n\n\n\n\nThere are a couple of things to note:\n\n\n\n\nWe have included two \n<input>\n tags.\n\n\nWe inject the value using \n{}\n notation.\n\n\n\n\nWhen you run it, you will see your data now displayed in two text fields.  But what happens when you type in the inputs?  Currently, still nothing.\n\n\nCascade works with \none way data binding\n, meaning that changes to data flow from \nApplication State\n to \nComponents\n not the other way around.  This is to prevent \ncircular references\n, where an update moves from A to B to C and so on, but somehow goes back to A.  If that happens, we will end up in an infinite loop.\n\n\nSo, any changes to our \nUser\n will show up in our \nUserView\n, but changes to our \nUserView\n don't automatically go back to our \nUser\n.  In order for that to happen, we need to handle \nEvents\n.\n\n\nAn \nEvent\n is triggered when something happens, like when a user clicks the mouse, or presses a key.  It can even happen when an AJAX call completes.  Normally, a program will execute its instructions until there is nothing left to do, and it will either end, or wait for input.  So, we need to handle that input.\n\n\nFor our \nUserView\n add these two methods above the \nrender\n method.\n\n\nupdateFirstName = (event) => {\n    this.props.user.firstName = event.target.value;\n}\n\nupdateLastName = (event) => {\n    this.props.user.lastName = event.target.value;\n}\n\n\n\n\nThere are a couple of things to note:\n\n\n\n\nThese methods will handle the \nEvent\n, and store the value of the target into our \nUser\n.\n\n\nWe are using the \nArrow Function\n notation, as the \nthis\n value may be changed while executing.\n\n\n\n\nBut how do we hook these handlers up to our inputs?\n\n\n<p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName} /></p>\n\n\n\n\nAnd that's it!  Any time the user updates the text inputs, the \nEvent\n is triggered, and the \nUser\n is updated.\n\n\nWe could also use regular methods instead of Arrow Functions for \nupdateFirstName\n and \nupdateLastName\n.  In that case, when we inject them, we must use \nFunction.bind()\n.\n\n\n<p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName.bind(this)} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName.bind(this)} /></p>\n\n\n\n\nIn many cases, this syntax is harder to read, but it is personal preference.  In some cases, where you must inject a specific value into the method, \nFunction.bind(this, value)\n is useful.\n\n\nRunning our Application\n\n\nSo, we can now display and update our \nUser\n.  Try running it and see what happens!",
            "title": "Updating Data"
        },
        {
            "location": "/Tutorials/0.2-Updating-Data/#observable-properties",
            "text": "Cascade provides  Observable  properties for objects.  Once established, these special properties may be  subscribed  to.  Then, if the value of the property changes, the subscribers will be notified with the updated value.  These special properties can be read and written to exactly like regular properties.  We can use the TypeScript decorator  @observable  in the class definition to make a property observable.  @observable property: type = value;  If we don't want to use the decorator, we can attach an observable property to an object with the call:  Cascade.createObservable<T>(obj: any, property: string, value?: T);  Let's take our  User  example from the last chapter, and make it observable.  So, simply import the  @observable  decorator, and add it in front of any properties you want to observe.  import { observable } from 'cascade';\n\nexport default class User {\n    @observable firstName: string;\n    @observable lastName: string;\n}  And there we have it!  Our  firstName  and  lastName  properties are now Observables!",
            "title": "Observable Properties"
        },
        {
            "location": "/Tutorials/0.2-Updating-Data/#handling-input",
            "text": "Now that we can watch for changes in our data, let's set up some inputs!    export default class UserView extends Component<IUserViewProps> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n                <p>First name: <input type=\"text\" value={user.firstName} /></p>\n                <p>Last name: <input type=\"text\" value={user.lastName} /></p>\n            </div>\n        );\n    }\n}  There are a couple of things to note:   We have included two  <input>  tags.  We inject the value using  {}  notation.   When you run it, you will see your data now displayed in two text fields.  But what happens when you type in the inputs?  Currently, still nothing.  Cascade works with  one way data binding , meaning that changes to data flow from  Application State  to  Components  not the other way around.  This is to prevent  circular references , where an update moves from A to B to C and so on, but somehow goes back to A.  If that happens, we will end up in an infinite loop.  So, any changes to our  User  will show up in our  UserView , but changes to our  UserView  don't automatically go back to our  User .  In order for that to happen, we need to handle  Events .  An  Event  is triggered when something happens, like when a user clicks the mouse, or presses a key.  It can even happen when an AJAX call completes.  Normally, a program will execute its instructions until there is nothing left to do, and it will either end, or wait for input.  So, we need to handle that input.  For our  UserView  add these two methods above the  render  method.  updateFirstName = (event) => {\n    this.props.user.firstName = event.target.value;\n}\n\nupdateLastName = (event) => {\n    this.props.user.lastName = event.target.value;\n}  There are a couple of things to note:   These methods will handle the  Event , and store the value of the target into our  User .  We are using the  Arrow Function  notation, as the  this  value may be changed while executing.   But how do we hook these handlers up to our inputs?  <p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName} /></p>  And that's it!  Any time the user updates the text inputs, the  Event  is triggered, and the  User  is updated.  We could also use regular methods instead of Arrow Functions for  updateFirstName  and  updateLastName .  In that case, when we inject them, we must use  Function.bind() .  <p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName.bind(this)} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName.bind(this)} /></p>  In many cases, this syntax is harder to read, but it is personal preference.  In some cases, where you must inject a specific value into the method,  Function.bind(this, value)  is useful.",
            "title": "Handling Input"
        },
        {
            "location": "/Tutorials/0.2-Updating-Data/#running-our-application",
            "text": "So, we can now display and update our  User .  Try running it and see what happens!",
            "title": "Running our Application"
        },
        {
            "location": "/Tutorials/0.3-Computed-Properties/",
            "text": "We've looked at creating \nObservable\n properties, which let us watch for changes in our \nApplication State\n.  But how do our \nComponents\n track those changes?\n\n\nIf you look at the \nUserView.render\n method, we simply read from our \nUser\n.  Cascade tracked those changes for us automatically using \nComputed\n properties.  For our Components, this is done behind the scenes.  But we can use them in our Application State just as easily.\n\n\nComputed Properties\n\n\nCascade provides \nComputed\n properties for objects, which use a getter function to produce a value.  However, any \nObservable\n properties used in this function, will automatically produce subscriptions.\n\n\nFor simplicity, we can also use the \n@observable\n decorator, except in front of a getter function.\n\n\n@observable get property(): type {\n    return this.value;\n}\n\n\n\n\nFor our \nUser\n let's add a \nfullName\n Computed property.  Add this right under the \nfirstName\n and \nlastName\n properties.\n\n\n@observable get fullName() {\n    return this.firstName + ' ' + this.lastName;\n}\n\n\n\n\nThere are a couple things to note:\n\n\n\n\nWe simply used the values in order to subscribe to them automatically.\n\n\nWe can use as many values as we want.\n\n\nWhatever we return from this method will be the value of the property.\n\n\n\n\nSubscribing Directly to Observables\n\n\nThere are two main ways of subscribing to \nObservable\n properties.  We may either subscribe directly, or through a \nComputed\n property, which we will examine next.\n\n\nCascade.subscribe<T>(obj: any, property: string, subscriberFunction: ISubscriberFunction<T>);\n\n\n\n\nThe \nsubscriberFunction\n will be called any time the value of the property changes.  Keep in mind, simply storing an identical value to the property is not a change, and so there will be no notification.",
            "title": "Computed Properties"
        },
        {
            "location": "/Tutorials/0.3-Computed-Properties/#computed-properties",
            "text": "Cascade provides  Computed  properties for objects, which use a getter function to produce a value.  However, any  Observable  properties used in this function, will automatically produce subscriptions.  For simplicity, we can also use the  @observable  decorator, except in front of a getter function.  @observable get property(): type {\n    return this.value;\n}  For our  User  let's add a  fullName  Computed property.  Add this right under the  firstName  and  lastName  properties.  @observable get fullName() {\n    return this.firstName + ' ' + this.lastName;\n}  There are a couple things to note:   We simply used the values in order to subscribe to them automatically.  We can use as many values as we want.  Whatever we return from this method will be the value of the property.",
            "title": "Computed Properties"
        },
        {
            "location": "/Tutorials/0.3-Computed-Properties/#subscribing-directly-to-observables",
            "text": "There are two main ways of subscribing to  Observable  properties.  We may either subscribe directly, or through a  Computed  property, which we will examine next.  Cascade.subscribe<T>(obj: any, property: string, subscriberFunction: ISubscriberFunction<T>);  The  subscriberFunction  will be called any time the value of the property changes.  Keep in mind, simply storing an identical value to the property is not a change, and so there will be no notification.",
            "title": "Subscribing Directly to Observables"
        }
    ]
}